# blog_writer/agent.py
import json, time
from pathlib import Path
from google.adk.agents.llm_agent import Agent

from .tools.research import research_topic
from .tools.writer import write_draft
from .tools.seo_checker import edit_post

root_agent = Agent(
    model="gemini-2.5-flash",
    name="blog_writer_root",
    description="Everyday-life blog writer.",
    instruction=(
        "You are a blog-writing assistant. "
        "The application code handles all tools and orchestration. "
        "For each user message, ONLY return the final blog post text in markdown format. "
        "Do NOT show Python code, function calls, or tool invocations."
    ),
)



def _text_from_request(req):
    if req is None:
        return ""
    if isinstance(req, str):
        return req.strip()
    for attr in ("user_message", "text", "message"):
        val = getattr(req, attr, None)
        if val:
            return str(val).strip()
    return str(req)

def _parse_user_input(text: str):
    """
    Very simple parser:
      - if 'key=value' pairs are present, use them
      - otherwise treat whole text as topic.
    Supported keys: topic, tone, audience, keywords
    """
    topic = text or "untitled topic"
    tone = "conversational"
    audience = "general readers"
    keywords = []

    if "=" in text and ("topic=" in text or "tone=" in text or "audience=" in text):
        parts = [p.strip() for p in text.replace(";", " ").split() if "=" in p]
        parsed = {}
        for p in parts:
            k, v = p.split("=", 1)
            parsed[k.strip().lower()] = v.strip()

        topic = parsed.get("topic", topic)
        tone = parsed.get("tone", tone)
        audience = parsed.get("audience", audience)
        if parsed.get("keywords"):
            keywords = [k.strip() for k in parsed["keywords"].split(",") if k.strip()]

    return topic, tone, audience, keywords

def _to_markdown(blog: dict) -> str:
    title = blog.get("title", "Untitled")
    intro = blog.get("intro", "")
    outline = blog.get("outline", [])
    sections = blog.get("sections", {})
    seo_notes = blog.get("seo_notes", [])

    md = f"# {title}\n\n"
    if intro:
        md += f"## Introduction\n{intro}\n\n"
    for h in outline:
        md += f"## {h}\n{sections.get(h, '')}\n\n"

    if seo_notes:
        md += "## SEO notes (for author only)\n"
        for note in seo_notes:
            md += f"- {note}\n"
        md += "\n"

    md += "\n---\nGenerated by blog_writer_root.\n"
    return md


def handle_root_request(request, agent=None):
    text = _text_from_request(request).strip()

    # 1) Empty input â†’ greeting
    if not text:
        return (
            "Hi! I'm your Blog Writer assistant.\n\n"
            "Tell me what you want a blog post about, and optionally add preferences, for example:\n"
            "- deep work in college\n"
            "- topic=how to start a tech blog tone=casual audience=beginners keywords=blogging,SEO\n"
        )

    # 2) For ANY non-empty text, go straight to pipeline
    topic, tone, audience, keywords = _parse_user_input(text)

    research = research_topic(topic)
    draft = write_draft(
        topic=topic,
        tone=tone,
        audience=audience,
        outline=research.get("outline", []),
        facts=research.get("facts", []),
    )
    final_blog = edit_post(draft, keywords)

    try:
        Path("outputs/drafts").mkdir(parents=True, exist_ok=True)
        out_path = Path("outputs/drafts") / f"root_output_{int(time.time())}.json"
        out_path.write_text(json.dumps(final_blog, indent=2))
    except Exception:
        pass

    return _to_markdown(final_blog)
